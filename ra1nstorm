#!/usr/bin/env python3

# Made by MiniExploit

import shutil
import os, sys
from tempfile import TemporaryDirectory
import subprocess
from others.ipsw import IPSW
from others.manifest import Manifest
from others.restore import Restore
from others.dependencies import check_requirements
from others.kerneldiff import diff_kernel
from others.error import *
from others.device import Device
from others import device, api
import argparse
import time

os.chdir(os.path.dirname(sys.argv[0]))

def decrypt(path, type, tmpdir, iv=None, key=None):
	dargs = [
		'img4',
		'-i',
		path,
		'-o',
		f'{tmpdir}/{type}.dec'
	]
	if iv and key:
		dargs.append('-k')
		dargs.append(f'{iv}{key}')
	retassure(subprocess.run(dargs, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL).returncode == 0, f"Failed to decrypt {type}")

def patch_bootloader(path, type, device, buildid, tmpdir):
	print(f"Patching {type}...")
	try:
		iBSS_iv, iBSS_key, iBEC_iv, iBEC_key = api.get_keys(device.identifier, device.board, buildid)
		no_key = False
	except TypeError:
		no_key = True
	if not no_key:
		if type == "iBSS":
			decrypt(path, type, tmpdir, iBSS_iv, iBSS_key)
		if type == "iBEC":
			decrypt(path, type, tmpdir, iBEC_iv, iBEC_key)
	else:
		if type == "iBSS":
			decrypt(path, type, tmpdir)
		if type == "iBEC":
			decrypt(path, type, tmpdir)

	retassure(subprocess.run(('kairos',f'{tmpdir}/{type}.dec',f'{tmpdir}/{type}.patched','-n'), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL).returncode == 0, f"Failed to patch {type}")

def patch_kernel(kernelcache, kernelorg, output, tmpdir):
	print("Patching kernelcache...")
	patch_kcache = subprocess.run(('Kernel64Patcher',kernelcache,f'{tmpdir}/kcache.patched','-a'), stdout=subprocess.DEVNULL)
	retassure(patch_kcache.returncode == 0, "Failed to patch kernelcache AMFI")
	diff_kernel(kernelcache, f'{tmpdir}/kcache.patched', f"{tmpdir}/kcache.diff")
	pack_krnl = subprocess.run(('img4','-i',kernelorg,'-o',output,'-T','rkrn','-P', f"{tmpdir}/kcache.diff"), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
	retassure(pack_krnl.returncode == 0, "Failed to pack kernelcache")

def patch_ramdisk(ramdisk, output, tmpdir):
	print("Patching ramdisk...")
	os.makedirs(f"{tmpdir}/rdsk_mnpt")
	# Attach ramdisk to the mountpoint
	attach_rdsk = subprocess.run(('hdiutil','attach', ramdisk, '-mountpoint',f'{tmpdir}/rdsk_mnpt'), stdout=subprocess.DEVNULL)
	retassure(attach_rdsk.returncode == 0, "Failed to mount ramdisk")
	# Patch asr
	shutil.move(f'{tmpdir}/rdsk_mnpt/usr/sbin/asr', f'{tmpdir}/asr.extracted')
	asr64 = subprocess.run(('asr64_patcher',f'{tmpdir}/asr.extracted',f'{tmpdir}/patched_asr'), stdout=subprocess.DEVNULL)
	detachret(asr64.returncode == 0, "Failed to patch asr", f'{tmpdir}/rdsk_mnpt')
	ents = subprocess.run(('ldid', '-e', f'{tmpdir}/asr.extracted'), stdout=subprocess.PIPE, universal_newlines=True)
	detachret(ents.returncode == 0, "Failed to extract ASR entitlements", f'{tmpdir}/rdsk_mnpt')
	with open(f'{tmpdir}/asr.xml', 'w') as f:
		f.write(ents.stdout)
	sign_asr = subprocess.run(('ldid','-Cadhoc',f'-Kothers/signcert.p12',f'-S{tmpdir}/asr.xml',f'{tmpdir}/patched_asr'), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, universal_newlines=True) # Thanks Cryptic
	detachret(sign_asr.returncode == 0, "Failed to sign patched ASR", f'{tmpdir}/rdsk_mnpt')
	os.chmod(f'{tmpdir}/patched_asr', 0o755)
	shutil.move(f'{tmpdir}/patched_asr', f'{tmpdir}/rdsk_mnpt/usr/sbin/asr')
	time.sleep(3)
	# Place patched libimg4 into ramdisk
	os.remove(f'{tmpdir}/rdsk_mnpt/usr/lib/libimg4.dylib')
	shutil.copyfile('others/libimg4.dylib', f'{tmpdir}/rdsk_mnpt/usr/lib/libimg4.dylib')
	time.sleep(3)
	# Detach ramdisk
	detach = subprocess.run(('hdiutil','detach',f'{tmpdir}/rdsk_mnpt'), stdout=subprocess.DEVNULL)
	retassure(detach.returncode == 0, "Failed to ummount ramdisk")
	os.rmdir(f"{tmpdir}/rdsk_mnpt")
	pack_rdsk = subprocess.run(('img4','-i',ramdisk,'-o',output,'-A','-T','rdsk'), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
	retassure(pack_rdsk.returncode == 0, "Failed to pack ramdisk")

def main():
	parser = argparse.ArgumentParser(description='ra1nstorm - Tethered downgrade 64-bit iDevices vulnerable to checkm8', usage="ra1nstorm iPSW [-u] [-s PATH] [-t BLOB]")
	parser.add_argument('-t','--blob',nargs=1, metavar='BLOB', help='Manually specify SHSH used for restoring (SHSH will be automatically saved if this argument is skipped)')
	parser.add_argument('ipsw', metavar='iPSW', nargs=1, help='iPSW file used for restoring')
	parser.add_argument('-s','--save-log',nargs=1, metavar='PATH', help='Specify path for saving futurerestore log')
	parser.add_argument('-u', '--update', help='Keep data while restoring (Untested)', action='store_true')
	args = parser.parse_args()
	if args.save_log:
		retassure(os.path.isdir(args.save_log[0]), "Provided path to save log is not a directory")

	check_requirements()
	ipsw = IPSW(args.ipsw[0])
	device = Device()
	buildmanifest = Manifest(ipsw.read_file('BuildManifest.plist'))
	ipsw.verify_ipsw_to_be_valid_for_connected_device(device.identifier)
	ipsw.get_ipswinfo(buildmanifest)
	_ibss = buildmanifest.get_comp(device.board, 'iBSS')
	_ibec = buildmanifest.get_comp(device.board, 'iBEC')
	with TemporaryDirectory() as tmpdir:
		if args.update:
			print("[WARNING] -u/--update option is untested, use it at your own risk!")

		ramdisk_path = buildmanifest.get_comp(device.board, 'RestoreRamDisk')
		ipsw.extract_file(_ibss, f'{tmpdir}/ibss.extracted')
		ipsw.extract_file(_ibec, f'{tmpdir}/ibec.extracted')
		patch_bootloader(f'{tmpdir}/ibss.extracted', 'iBSS', device, buildmanifest.get_buildid(), tmpdir)
		patch_bootloader(f'{tmpdir}/ibec.extracted', 'iBEC', device, buildmanifest.get_buildid(), tmpdir)
		ipsw.extract_file(ramdisk_path, f"{tmpdir}/ramdisk_org.dmg")
		unpack_rdsk = subprocess.run(('img4','-i',f"{tmpdir}/ramdisk_org.dmg",'-o',f"{tmpdir}/ramdisk.dmg"), stdout=subprocess.DEVNULL)
		retassure(unpack_rdsk.returncode == 0, "Failed to unpack ramdisk")
		kernelcache = buildmanifest.get_comp(device.board, 'RestoreKernelCache')
		ipsw.extract_file(kernelcache ,f"{tmpdir}/kernelcache.release.extracted")
		unpack_krnl = subprocess.run(('img4','-i',f"{tmpdir}/kernelcache.release.extracted",'-o',f"{tmpdir}/kcache.raw"), stdout=subprocess.DEVNULL)
		retassure(unpack_krnl.returncode == 0, "Failed to unpack kernelcache")
		patch_ramdisk(f'{tmpdir}/ramdisk.dmg', f'{tmpdir}/ramdisk.im4p', tmpdir)
		patch_kernel(f'{tmpdir}/kcache.raw', f'{tmpdir}/kernelcache.release.extracted', f'{tmpdir}/kernelcache.im4p', tmpdir)
		restore = Restore(device, args.ipsw[0])
		if not os.path.exists(f"{tmpdir}/tempblobs"):
			os.makedirs(f'{tmpdir}/tempblobs')
		if not os.path.exists(f'{tmpdir}/apnonceblobs'):
			os.makedirs(f'{tmpdir}/apnonceblobs')
		if not args.blob:
			restore.save_blobs(f'{tmpdir}/apnonceblobs', True)
			restore.save_im4m(f'{tmpdir}/im4m')
		else:
			restore.save_im4m(f'{tmpdir}/im4m', args.blob[0])
		restore.sign_bootloader(f'{tmpdir}/iBSS.patched',f'{tmpdir}/ibss.{device.board}.patched.img4','iBSS')
		restore.sign_bootloader(f'{tmpdir}/iBEC.patched',f'{tmpdir}/ibec.{device.board}.patched.img4','iBEC')
		if not args.blob:
			restore.save_blobs(f'{tmpdir}/tempblobs', False)
		if not args.blob:
			if args.save_log:
				restore.restore(f'{tmpdir}/ibss.{device.board}.patched.img4', f'{tmpdir}/ibec.{device.board}.patched.img4', f'{tmpdir}/ramdisk.im4p', f'{tmpdir}/kernelcache.im4p', args.update, log_path=args.save_log[0])
			else:
				restore.restore(f'{tmpdir}/ibss.{device.board}.patched.img4', f'{tmpdir}/ibec.{device.board}.patched.img4', f"{tmpdir}/ramdisk.im4p", f'{tmpdir}/kernelcache.im4p', args.update)
		else:
			if args.save_log:
				restore.restore(f'{tmpdir}/ibss.{device.board}.patched.img4', f'{tmpdir}/ibec.{device.board}.patched.img4', f"{tmpdir}/ramdisk.im4p", f'{tmpdir}/kernelcache.im4p', args.update, custom_blob=args.blob[0], log_path=args.save_log[0])	
			else:
				restore.restore(f'{tmpdir}/ibss.{device.board}.patched.img4', f'{tmpdir}/ibec.{device.board}.patched.img4', f"{tmpdir}/ramdisk.im4p", f'{tmpdir}/kernelcache.im4p', args.update, custom_blob=args.blob[0])

if __name__ == '__main__':
	try:
		main()
	except Exception as e:
		print("ra1nstorm failed with exception:")
		print(f"[exception]:")
		print(f"what={e}")



