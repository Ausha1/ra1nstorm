#!/usr/bin/env python3

# Made by MiniExploit

import shutil
import os, sys
from tempfile import TemporaryDirectory
import subprocess
from others.ipsw import IPSW
from others.manifest import Manifest
from others.restore import Restore
from others.dependencies import check_requirements
from others.kerneldiff import diff_kernel
from others.error import retassure
from others.device import Device
from others import device, api
import argparse
import platform
import time
import pathlib

def decrypt(path, iv, key, type, tmpdir):
	dec = subprocess.run(('img4','-i', path , '-o', f'{tmpdir}/{type}.dec','-k',f'{iv}{key}'), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
	retassure(dec.returncode == 0, f"Failed to decrypt {type}. Exiting.")

def patch_bootloader(path, type, device, buildid, tmpdir):
	print(f"Patching {type}...")
	iBSS_iv, iBSS_key, iBEC_iv, iBEC_key = api.get_keys(device.identifier, device.board, buildid)
	if type == "iBSS":
		decrypt(path, iBSS_iv, iBSS_key, type, tmpdir)
	if type == "iBEC":
		decrypt(path, iBEC_iv, iBEC_key, type, tmpdir)
	pargs = [
		'Kairos',
		f'{tmpdir}/{type}.dec',
		f'{tmpdir}/{type}.patched'
	]
	if type == "iBEC":
		pargs.append('-n')
	patch = subprocess.run(pargs, stdout=subprocess.DEVNULL)
	retassure(patch.returncode == 0, f"Failed to patch {type}. Exiting.")

def patch_kernel(kernelcache, kernelorg, output, tmpdir):
	print("Patching kernelcache...")
	patch_kcache = subprocess.run(('Kernel64Patcher',kernelcache,f'{tmpdir}/kcache.patched','-a'), stdout=subprocess.DEVNULL)
	retassure(patch_kcache.returncode == 0, "Failed to patch kernelcache AMFI. Exiting.")
	diff_kernel(kernelcache, f'{tmpdir}/kcache.patched', f"{tmpdir}/kcache.diff")
	pack_krnl = subprocess.run(('img4','-i',kernelorg,'-o',output,'-T','rkrn','-P', f"{tmpdir}/kcache.diff"), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
	retassure(pack_krnl.returncode == 0, "Failed to pack kernelcache. Exiting.")

def patch_ramdisk(ramdisk, output, tmpdir):
	print("Patching ramdisk...")
	os.makedirs(f"{tmpdir}/rdsk_mnpt")
	attach_rdsk = subprocess.run(('hdiutil','attach', ramdisk, '-mountpoint',f'{tmpdir}/rdsk_mnpt'), stdout=subprocess.DEVNULL)
	retassure(attach_rdsk.returncode == 0, "Failed to mount ramdisk. Exiting.")
	shutil.move(f'{tmpdir}/rdsk_mnpt/usr/sbin/asr', f'{tmpdir}/asr.extracted')
	asr64 = subprocess.run(('asr64_patcher',f'{tmpdir}/asr.extracted',f'{tmpdir}/patched_asr'), stdout=subprocess.DEVNULL)
	retassure(asr64.returncode == 0, "Failed to patch asr. Exiting.")
	ents = subprocess.run(('ldid', '-e', f'{tmpdir}/asr.extracted'), stdout=subprocess.PIPE, universal_newlines=True)
	retassure(ents.returncode == 0, "Failed to extract ASR entitlements. Exiting.")
	with open(f'{tmpdir}/asr.xml', 'w') as f:
		f.write(ents.stdout)
	# TODO: Patch libimg4
	sign_asr = subprocess.run(('ldid','-Cadhoc','-Kothers/signcert.p12',f'-S{tmpdir}/asr.xml',f'{tmpdir}/patched_asr'), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) # Thanks Cryptic
	retassure(sign_asr.returncode == 0, "Failed to sign patched ASR. Exiting.")
	os.chmod(f'{tmpdir}/patched_asr', 0o755)
	shutil.move(f'{tmpdir}/patched_asr', f'{tmpdir}/rdsk_mnpt/usr/sbin/asr')
	time.sleep(3)
	detach = subprocess.run(('hdiutil','detach',f'{tmpdir}/rdsk_mnpt'), stdout=subprocess.DEVNULL)
	retassure(detach.returncode == 0, "Failed to ummount ramdisk. Exiting.")
	os.rmdir(f"{tmpdir}/rdsk_mnpt")
	pack_rdsk = subprocess.run(('img4','-i',ramdisk,'-o',output,'-A','-T','rdsk'), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
	retassure(pack_rdsk.returncode == 0, "Failed to pack ramdisk. Exiting.")

def main():
	parser = argparse.ArgumentParser(description='ra1nstorm - Tethered downgrade 64-bit iDevices vulnerable to checkm8', usage="ra1nstorm iPSW [-u]")
	parser.add_argument('ipsw', metavar='iPSW', nargs=1, help='iPSW file used for restoring')
	parser.add_argument('-s','--save-log',nargs=1, metavar='PATH', help='Specify path for saving futurerestore log')
	parser.add_argument('-u', '--update', help='Keep data while restoring (Untested)', action='store_true')
	args = parser.parse_args()
	os.chdir(pathlib.Path().resolve())
	if args.save_log:
		retassure(os.path.isdir(args.save_log[0]), "Provided path to save log is not a directory. Exiting.")

	check_requirements()
	ipsw = IPSW(args.ipsw[0])
	device = Device()
	#retassure(device.issupported(identifier), "Device is not supported. Exiting.")
	buildmanifest = Manifest(ipsw.read_file('BuildManifest.plist'))
	ipsw.verify_ipsw_to_be_valid_for_connected_device(device.identifier, buildmanifest)
	ipsw.get_ipswinfo(buildmanifest)
	_ibss = buildmanifest.get_comp(device.board, 'iBSS')
	_ibec = buildmanifest.get_comp(device.board, 'iBEC')
	with TemporaryDirectory() as tmpdir:
		if args.update:
			print("[WARNING] -u/--update option is untested, use it at your own risk!")

		ramdisk_path = buildmanifest.get_comp(device.board, 'RestoreRamDisk')
		ipsw.extract_file(_ibss, f'{tmpdir}/ibss.extracted')
		ipsw.extract_file(_ibec, f'{tmpdir}/ibec.extracted')
		patch_bootloader(f'{tmpdir}/ibss.extracted', 'iBSS', device, buildmanifest.get_buildid(), tmpdir)
		patch_bootloader(f'{tmpdir}/ibec.extracted', 'iBEC', device, buildmanifest.get_buildid(), tmpdir)
		ipsw.extract_file(ramdisk_path, f"{tmpdir}/ramdisk_org.dmg")
		unpack_rdsk = subprocess.run(('img4','-i',f"{tmpdir}/ramdisk_org.dmg",'-o',f"{tmpdir}/ramdisk.dmg"), stdout=subprocess.DEVNULL)
		retassure(unpack_rdsk.returncode == 0, "Failed to unpack ramdisk. Exiting.")
		kernelcache = buildmanifest.get_comp(device.board, 'RestoreKernelCache')
		ipsw.extract_file(kernelcache ,f"{tmpdir}/kernelcache.release.extracted")
		unpack_krnl = subprocess.run(('img4','-i',f"{tmpdir}/kernelcache.release.extracted",'-o',f"{tmpdir}/kcache.raw"), stdout=subprocess.DEVNULL)
		retassure(unpack_krnl.returncode == 0, "Failed to unpack kernelcache. Exiting.")
		patch_ramdisk(f'{tmpdir}/ramdisk.dmg', f'{tmpdir}/ramdisk.im4p', tmpdir)
		patch_kernel(f'{tmpdir}/kcache.raw', f'{tmpdir}/kernelcache.release.extracted', f'{tmpdir}/kernelcache.im4p', tmpdir)
		restore = Restore(device, args.ipsw[0])
		if not os.path.exists(f"{tmpdir}/tempblobs"):
			os.makedirs(f'{tmpdir}/tempblobs')
		if not os.path.exists(f'{tmpdir}/apnonceblobs'):
			os.makedirs(f'{tmpdir}/apnonceblobs')
		restore.save_blobs(f'{tmpdir}/apnonceblobs', True)
		restore.save_im4m(f'{tmpdir}/im4m')
		if not os.path.exists("/tmp/futurerestore"):
			os.makedirs("/tmp/futurerestore")
		restore.sign_bootloader(f'{tmpdir}/iBSS.patched',f'/tmp/futurerestore/ibss.{device.board}.{buildmanifest.get_buildid()}.patched.img4','iBSS')
		restore.sign_bootloader(f'{tmpdir}/iBEC.patched',f'/tmp/futurerestore/ibec.{device.board}.{buildmanifest.get_buildid()}.patched.img4','iBEC')
		restore.save_blobs(f'{tmpdir}/tempblobs', False)
		if args.save_log:
			restore.restore(f"{tmpdir}/ramdisk.im4p", f'{tmpdir}/kernelcache.im4p', args.update, args.save_log[0])
		else:
			restore.restore(f"{tmpdir}/ramdisk.im4p", f'{tmpdir}/kernelcache.im4p', args.update)

if __name__ == '__main__':
	main()



